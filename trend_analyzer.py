"""
üìä –°–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–µ–Ω–¥–æ–≤ —Å –≤–Ω–µ—à–Ω–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç CoinGecko + Binance –¥–ª—è –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
"""

import json
import requests
import time
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path

@dataclass
class TrendPoint:
    """üìç –¢–æ—á–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–Ω–¥–∞"""
    timestamp: datetime
    price: float
    volume: float
    source: str

    def to_dict(self):
        return {
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'volume': self.volume,
            'source': self.source
        }

    @classmethod
    def from_dict(cls, data):
        return cls(
            timestamp=datetime.fromisoformat(data['timestamp']),
            price=data['price'],
            volume=data['volume'],
            source=data['source']
        )

class TrendDataStorage:
    """üíæ –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–Ω–¥–æ–≤"""

    def __init__(self):
        self.data_dir = Path('data/trends')
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.current_file = self.data_dir / 'current_trends.json'
        self.logger = logging.getLogger(__name__)

    def save_trend_data(self, points: List[TrendPoint]):
        """üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 48 —á–∞—Å–æ–≤
            data = {
                'last_update': datetime.now().isoformat(),
                'points': [point.to_dict() for point in points[-288:]]
            }

            with open(self.current_file, 'w') as f:
                json.dump(data, f, indent=2)

        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")

    def load_trend_data(self) -> List[TrendPoint]:
        """üìÇ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            if not self.current_file.exists():
                return []

            with open(self.current_file, 'r') as f:
                data = json.load(f)

            return [TrendPoint.from_dict(point) for point in data.get('points', [])]

        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
            return []

class ExternalMarketData:
    """üåê –í–Ω–µ—à–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def get_coingecko_data(self, days=1) -> List[TrendPoint]:
        """ü¶é –î–∞–Ω–Ω—ã–µ CoinGecko"""
        try:
            url = "https://api.coingecko.com/api/v3/coins/dogecoin/market_chart"
            params = {
                'vs_currency': 'eur',
                'days': str(days),
                'interval': 'hourly'
            }

            response = requests.get(url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()

            points = []
            for timestamp_ms, price in data['prices'][-48:]:
                points.append(TrendPoint(
                    timestamp=datetime.fromtimestamp(timestamp_ms / 1000),
                    price=price,
                    volume=0,
                    source='coingecko'
                ))

            self.logger.info(f"üìä CoinGecko: {len(points)} —Ç–æ—á–µ–∫")
            return points

        except Exception as e:
            self.logger.error(f"‚ùå CoinGecko: {e}")
            return []

    def get_binance_data(self) -> List[TrendPoint]:
        """üü° –î–∞–Ω–Ω—ã–µ Binance"""
        try:
            url = "https://api.binance.com/api/v3/klines"
            params = {
                'symbol': 'DOGEEUR',
                'interval': '1h',
                'limit': 48
            }

            response = requests.get(url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()

            points = []
            for kline in data:
                points.append(TrendPoint(
                    timestamp=datetime.fromtimestamp(int(kline[0]) / 1000),
                    price=float(kline[4]),  # Close price
                    volume=float(kline[5]),
                    source='binance'
                ))

            self.logger.info(f"üìä Binance: {len(points)} —Ç–æ—á–µ–∫")
            return points

        except Exception as e:
            self.logger.error(f"‚ùå Binance: {e}")
            return []

class TrendAnalyzer:
    """üìà –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —Ç—Ä–µ–Ω–¥–æ–≤"""

    def __init__(self):
        self.storage = TrendDataStorage()
        self.market_data = ExternalMarketData()
        self.logger = logging.getLogger(__name__)
        self.last_update = None
        self.cached_analysis = {}

    def update_market_data(self):
        """üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            all_points = []

            # –°–æ–±–∏—Ä–∞–µ–º –∏–∑ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
            all_points.extend(self.market_data.get_coingecko_data())
            all_points.extend(self.market_data.get_binance_data())

            if all_points:
                # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                unique_points = {}
                for point in all_points:
                    # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ —á–∞—Å–∞ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏
                    hour_key = point.timestamp.replace(minute=0, second=0, microsecond=0)
                    if hour_key not in unique_points or point.source == 'coingecko':
                        unique_points[hour_key] = point

                sorted_points = sorted(unique_points.values(), key=lambda x: x.timestamp)

                self.storage.save_trend_data(sorted_points)
                self.last_update = datetime.now()

                self.logger.info(f"üìä –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {len(sorted_points)} —Ç–æ—á–µ–∫")

        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}")

    def analyze_trend(self, hours_back=4) -> Dict:
        """üìà –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–∞"""
        try:
            points = self.storage.load_trend_data()
            if len(points) < 3:
                return {'trend': 'insufficient_data', 'confidence': 0}

            # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            cutoff = datetime.now() - timedelta(hours=hours_back)
            recent_points = [p for p in points if p.timestamp >= cutoff]

            if len(recent_points) < 2:
                return {'trend': 'insufficient_data', 'confidence': 0}

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            start_price = recent_points[0].price
            end_price = recent_points[-1].price
            price_change = (end_price - start_price) / start_price

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç—Ä–µ–Ω–¥
            if price_change > 0.03:      # +3%
                trend = 'strong_bullish'
            elif price_change > 0.01:    # +1%
                trend = 'bullish'
            elif price_change < -0.03:   # -3%
                trend = 'strong_bearish'
            elif price_change < -0.01:   # -1%
                trend = 'bearish'
            else:
                trend = 'sideways'

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
            if len(recent_points) > 2:
                prices = [p.price for p in recent_points]
                volatility = (max(prices) - min(prices)) / min(prices)
            else:
                volatility = 0

            analysis = {
                'trend': trend,
                'price_change_percent': price_change * 100,
                'volatility_percent': volatility * 100,
                'confidence': min(len(recent_points) / 10, 1.0),
                'data_points': len(recent_points),
                'start_price': start_price,
                'end_price': end_price,
                'hours_analyzed': hours_back,
                'timestamp': datetime.now().isoformat()
            }

            return analysis

        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {e}")
            return {'trend': 'error', 'confidence': 0}

    def should_allow_trading(self) -> Tuple[bool, str]:
        """üéØ –†–µ—à–µ–Ω–∏–µ –æ —Ç–æ—Ä–≥–æ–≤–ª–µ"""
        analysis = self.analyze_trend(hours_back=4)

        if analysis['confidence'] < 0.3:
            return False, "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö"

        trend = analysis['trend']
        change = analysis.get('price_change_percent', 0)

        if trend == 'strong_bearish' and change < -4:
            return False, f"–°–∏–ª—å–Ω—ã–π –º–µ–¥–≤–µ–∂–∏–π —Ç—Ä–µ–Ω–¥: {change:.1f}%"

        if analysis.get('volatility_percent', 0) > 8:
            return False, f"–í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {analysis['volatility_percent']:.1f}%"

        return True, f"–¢–æ—Ä–≥–æ–≤–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ ({trend}: {change:+.1f}%)"

    def get_cached_analysis(self, force_update=False) -> Dict:
        """‚ö° –ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑"""
        now = datetime.now()

        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
        if (force_update or not self.last_update or 
            (now - self.last_update).seconds > 600):
            self.update_market_data()

        # –û–±–Ω–æ–≤–ª—è–µ–º –∞–Ω–∞–ª–∏–∑ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
        cache_key = f"analysis_{now.hour}_{now.minute//5}"
        if cache_key not in self.cached_analysis:
            self.cached_analysis.clear()  # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫—ç—à

            analysis = {}
            for period in [1, 4, 24]:
                analysis[f'{period}h'] = self.analyze_trend(period)

            analysis['trading_allowed'], analysis['trading_reason'] = self.should_allow_trading()
            self.cached_analysis[cache_key] = analysis

        return self.cached_analysis[cache_key]

    def get_trend_summary(self) -> str:
        """üìã –ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞"""
        try:
            analysis = self.get_cached_analysis()
            trend_4h = analysis.get('4h', {})

            trend = trend_4h.get('trend', 'unknown')
            change = trend_4h.get('price_change_percent', 0)
            confidence = trend_4h.get('confidence', 0)

            if confidence < 0.3:
                return "üìä –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"

            emoji_map = {
                'strong_bullish': 'üöÄ',
                'bullish': 'üìà', 
                'sideways': '‚û°Ô∏è',
                'bearish': 'üìâ',
                'strong_bearish': 'üí•'
            }

            emoji = emoji_map.get(trend, '‚ùì')

            return f"{emoji} –¢—Ä–µ–Ω–¥ 4—á: {trend} ({change:+.1f}%, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.0%})"

        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {e}"

# –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –±–æ—Ç–æ–º
def integrate_trend_analysis(bot_instance):
    """üîó –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–π –±–æ—Ç"""

    if not hasattr(bot_instance, 'trend_analyzer'):
        bot_instance.trend_analyzer = TrendAnalyzer()

    def enhanced_buy_decision(original_decision):
        """üß† –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –æ –ø–æ–∫—É–ø–∫–µ"""
        if not original_decision:
            return False, "–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –ø—Ä–æ—Ç–∏–≤"

        try:
            allowed, reason = bot_instance.trend_analyzer.should_allow_trading()
            if not allowed:
                return False, f"–¢—Ä–µ–Ω–¥-–∞–Ω–∞–ª–∏–∑: {reason}"

            return True, f"–†–∞–∑—Ä–µ—à–µ–Ω–æ —Ç—Ä–µ–Ω–¥–æ–º: {reason}"

        except Exception as e:
            bot_instance.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–µ–Ω–¥-–∞–Ω–∞–ª–∏–∑–∞: {e}")
            return original_decision, "–ê–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"

    return enhanced_buy_decision

if __name__ == "__main__":
    # –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    analyzer = TrendAnalyzer()

    print("üìä –¢–ï–°–¢ –ê–ù–ê–õ–ò–ó–ê–¢–û–†–ê –¢–†–ï–ù–î–û–í")
    print("=" * 40)

    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
    print("üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...")
    analyzer.update_market_data()

    # –ü–æ–ª—É—á–∞–µ–º –∞–Ω–∞–ª–∏–∑
    analysis = analyzer.get_cached_analysis()

    for period in ['1h', '4h', '24h']:
        if period in analysis:
            trend_data = analysis[period]
            print(f"{period}: {trend_data.get('trend', 'N/A')} "
                  f"({trend_data.get('price_change_percent', 0):+.1f}%)")

    # –†–µ—à–µ–Ω–∏–µ –æ —Ç–æ—Ä–≥–æ–≤–ª–µ
    can_trade = analysis.get('trading_allowed', False)
    reason = analysis.get('trading_reason', 'N/A')
    print(f"\n–¢–æ—Ä–≥–æ–≤–ª—è: {'‚úÖ –†–ê–ó–†–ï–®–ï–ù–ê' if can_trade else '‚ùå –ó–ê–ü–†–ï–©–ï–ù–ê'}")
    print(f"–ü—Ä–∏—á–∏–Ω–∞: {reason}")

    # –ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞
    print(f"\n{analyzer.get_trend_summary()}")
